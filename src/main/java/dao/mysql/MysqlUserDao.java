package dao.mysql;

import dao.UserDao;
import entity.db.Permission;
import entity.db.Role;
import entity.db.User;
import org.apache.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class MysqlUserDao implements UserDao {

    private static final Logger LOGGER = Logger
            .getLogger(MysqlUserDao.class);

    private static final String CREATE_USER = "INSERT INTO football_forecast_users.user (login, password, idrole, name, surname, email, blocked) VALUES (?, ?, 2, ?, ?, ?, 0)";
    private static final String FIND_USER = "SELECT * FROM football_forecast_users.user WHERE login=? AND password=?";
    private static final String FIND_USERS = "SELECT * FROM football_forecast_users.user WHERE idRole=(SELECT idRole FROM football_forecast_users.role WHERE name='client')";
    private static final String FIND_ROLE = "SELECT * FROM role WHERE idRole=?";
    private static final String FIND_PERMISSIONS = "SELECT * FROM permission WHERE idPermission IN (SELECT idPermission FROM role_permission WHERE idRole=?)";
    private static final String VALIDATE_LOGIN = "SELECT * FROM football_forecast_users.user WHERE login=?";
    private static final String VALIDATE_EMAIL = "SELECT * FROM football_forecast_users.user WHERE email=?";
    private static final String BLOCK_USER = "UPDATE football_forecast_users.user " +
            "SET blocked = IF(blocked=0, 1, IF(blocked=1, 0, blocked))" +
            " WHERE idUser=?";

    public int insertUser(Connection conn, User user) throws SQLException {
        int autogeneratedId = 0;
        try (PreparedStatement pstm = conn.prepareStatement(CREATE_USER,
                Statement.RETURN_GENERATED_KEYS)) {
            pstm.setString(1, user.getLogin());
            pstm.setString(2, user.getPassword());
            pstm.setString(3, user.getName());
            pstm.setString(4, user.getSurname());
            pstm.setString(5, user.getEmail());
            pstm.executeUpdate();

            ResultSet rs = pstm.getGeneratedKeys();
            if (rs.next()) {
                autogeneratedId = rs.getInt(1);
            }
            LOGGER.debug("User have been created.");
        } catch (SQLException ex) {
            LOGGER.error("Cannot create user ", ex);
            throw ex;
        }
        user.setIdUser(autogeneratedId);
        return autogeneratedId;
    }

    public User getUser(Connection conn, String login, String password)
            throws SQLException {
        User result = null;
        try (PreparedStatement pstm = conn.prepareStatement(FIND_USER)) {
            pstm.setString(1, login);
            pstm.setString(2, password);
            ResultSet rs = pstm.executeQuery();
            if (rs.next()) {
                result = new User();
                result.setIdUser(rs.getInt(1));
                result.setLogin(rs.getString(2));
                result.setPassword(rs.getString(3));
                result.setIdRole(rs.getInt(4));
                result.setName(rs.getString(5));
                result.setSurname(rs.getString(6));
                result.setEmail(rs.getString(7));
                result.setBlocked(rs.getInt(8) != 0);
                LOGGER.debug("User have been read.");
            }
        } catch (SQLException ex) {
            LOGGER.error("Cannot read user ", ex);
            throw ex;
        }
        return result;
    }

    @Override
    public List<User> findUsers(Connection conn) throws SQLException {
        List<User> result = new ArrayList<User>();
        try (Statement stm = conn.createStatement()) {
            ResultSet rs = stm.executeQuery(FIND_USERS);
            while (rs.next()) {
                User currentUser = new User();
                currentUser.setIdUser(rs.getInt(1));
                currentUser.setLogin(rs.getString(2));
                currentUser.setPassword(rs.getString(3));
                currentUser.setIdRole(rs.getInt(4));
                currentUser.setName(rs.getString(5));
                currentUser.setSurname(rs.getString(6));
                currentUser.setEmail(rs.getString(7));
                currentUser.setBlocked(rs.getInt(8) != 0);
                result.add(currentUser);
            }
        } catch (SQLException ex) {
            LOGGER.error("Cannot read users ", ex);
            throw ex;
        }
        return result;
    }

    @Override
    public Role findRole(Connection conn, int idRole) throws SQLException {
        Role result = new Role();
        try (PreparedStatement pstm = conn.prepareStatement(FIND_ROLE)) {
            pstm.setInt(1, idRole);
            ResultSet rs = pstm.executeQuery();
            if (rs.next()) {
                result.setIdRole(rs.getInt(1));
                result.setName(rs.getString(2));
                result.setDescription(rs.getString(3));
                LOGGER.debug("Role have been read.");
            }
        } catch (SQLException ex) {
            LOGGER.error("Cannot read role ", ex);
            throw ex;
        }
        return result;
    }

    @Override
    public List<Permission> findPermissions(Connection conn, int idRole) throws SQLException {
        List<Permission> result = new ArrayList<Permission>();
        try (PreparedStatement pstm = conn.prepareStatement(FIND_PERMISSIONS)) {
            pstm.setInt(1, idRole);
            ResultSet rs = pstm.executeQuery();
            while (rs.next()) {
                Permission currentPermission = new Permission();
                currentPermission.setIdPermission(rs.getInt(1));
                currentPermission.setName(rs.getString(2));
                currentPermission.setDescription(rs.getString(3));
                result.add(currentPermission);
            }
        } catch (SQLException ex) {
            LOGGER.error("Can not read permissions ", ex);
            throw ex;
        }
        return result;
    }

    @Override
    public Boolean validateEmailOnDuplicateInsert(Connection conn, String email) throws SQLException {
        try(PreparedStatement pstm = conn.prepareStatement(VALIDATE_EMAIL)){
            pstm.setString(1, email);
            ResultSet rs = pstm.executeQuery();
            return !rs.next();
        }
    }

    @Override
    public Boolean validateLoginOnDuplicateInsert(Connection conn, String login) throws SQLException {
        try(PreparedStatement pstm = conn.prepareStatement(VALIDATE_LOGIN)){
            pstm.setString(1, login);
            ResultSet rs = pstm.executeQuery();
            return !rs.next();
        }
    }

    @Override
    public int blockUser(Connection conn, int idUser) throws SQLException {
        try(PreparedStatement pstm = conn.prepareStatement(BLOCK_USER)){
            pstm.setInt(1, idUser);
            pstm.executeUpdate();
        }
        return idUser;
    }

}
